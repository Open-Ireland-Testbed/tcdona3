diff --git a/.gitignore b/.gitignore
index 8d33dfe..d2712e5 100755
--- a/.gitignore
+++ b/.gitignore
@@ -163,3 +163,5 @@ cython_debug/
 #  and can be added to the global gitignore or merged into this file.  For a more nuclear
 #  option (not recommended) you can uncomment the following to ignore the entire idea folder.
 #.idea/
+changes_vs_main_final.txt
+changes_vs_main.txt
diff --git a/__init__.py b/__init__.py
index 976498a..bf23157 100644
--- a/__init__.py
+++ b/__init__.py
@@ -1 +1,69 @@
-__version__ = "1.0.3"
+# tcdona3/__init__.py
+"""
+Top-level package for the Open Ireland Optical Testbed v3 control code.
+
+Submodules are imported optionally: if a device module cannot be imported
+(e.g. missing vendor libraries, hardware-specific dependencies), it is
+silently skipped. Only successfully imported symbols are exposed in
+`tcdona3.__all__`.
+"""
+
+from importlib import import_module
+
+__all__ = []
+
+
+def _try_import(module_name: str, names: list) -> None:
+    """
+    Try to import `tcdona3.<module_name>` and re-export the given
+    attribute names if present. Failures are ignored so that
+    `import tcdona3` always succeeds.
+    """
+    try:
+        mod = import_module(f".{module_name}", __name__)
+    except ImportError:
+        # Optional dependency or environment-specific module failed to import
+        return
+
+    for name in names:
+        if hasattr(mod, name):
+            globals()[name] = getattr(mod, name)
+            __all__.append(name)
+
+
+# Core / top-level devices
+_try_import("polatis", ["Polatis", "PolatisNetconf"])
+_try_import("polatis_old", ["Polatis"])
+_try_import("lumentum", ["Lumentum"])
+_try_import("ila", ["ILA"])
+_try_import("cassini", ["Cassini"])
+_try_import("dicon", ["Dicon"])
+_try_import("bbsource", ["BBS"])
+
+# Monitoring
+_try_import("monitor", ["Monitor", "RoadmMonitor"])
+
+# OSA and related
+_try_import("osa", ["OSA"])
+_try_import("osa_server", ["OSAServer"])
+
+# Other instruments
+_try_import("yokogawa", ["Yokogawa"])
+_try_import("quadflex", ["QuadFlex"])
+_try_import("teraflex", ["TeraFlex"])
+_try_import("teraflex_paramiko", ["TeraFlexParamiko"])
+
+# Utilities (functions/constants only; safe to expose if import works)
+_try_import("utils", ["check_patch_owners", "load_csv_with_pandas"])  # extend if needed
+
+# ApexOSA subpackage
+_try_import("ApexOSA.apextls", ["ApexTLS"])
+_try_import("ApexOSA.osa", ["ApexOSA"])
+_try_import("ApexOSA.filter", ["ApexFilter"])
+_try_import("ApexOSA.ocsa", ["OCSA"])
+_try_import("ApexOSA.powermeter", ["PowerMeter"])
+_try_import("ApexOSA.polarimeter", ["Polarimeter"])
+_try_import("ApexOSA.Errors", ["ApexError"])
+_try_import("ApexOSA.Constantes", [])  # mostly constants; import only if you want to re-export them by name
+_try_import("ApexOSA.Common", [])      # same as above
+
diff --git a/polatis.py b/polatis.py
old mode 100755
new mode 100644
index ca348fa..42134f4
--- a/polatis.py
+++ b/polatis.py
@@ -1,594 +1,13 @@
-import sys
-import telnetlib
-import re
-import pandas as pd
-import time
-import os, getpass
-from datetime import datetime
-import sqlite3
-import csv
-import mysql.connector
-from tcdona3.utils import check_patch_owners
-
-
-def timeStamped(fname, fmt="%Y-%m-%d_{fname}"):
-    return datetime.now().strftime(fmt).format(fname=fname)
-
-
-class Polatis:
-
-    """Polatis class to interact with Polatis switch using telnet
-
-    :param host: The IP address of the Polatis switch, defaults to 10.10.10.28"
-    :type host: str
-
-    :param port: The port number of the Polatis switch, defaults to 3082
-    :type port: str
-
-    :return: None
-    :rtype: None
-    """
-
-    def __init__(self, host="10.10.10.28", port="3082"):
-        """Constructor method"""
-        self.telnet = telnetlib.Telnet(host, port)
-        self.eol = ";"
-        self.patch = {}
-        self.shutter = {}
-        self.monmode = {}
-        self.wavelength = {}
-        self.offset = {}
-        self.atime = {}
-        self.power = {}
-        self.label = {}
-
-    def __del__(self):
-        pass
-
-    def login(self):
-        """Login to the Polatis switch
-
-        :return: None
-        :rtype: None
-        """
-        return self.__sendcmd("ACT-USER::root:123::root;")
-
-    def logout(self):
-        #        print self.telnet.read_all()
-        self.__sendcmd("CANC-USER::root:123:;")
-        self.telnet.close()
-
-    def __sendcmd(self, line):
-        #        print "sending " + line
-        cmd_str = "%s\n" % line
-        self.telnet.write(cmd_str.encode("ascii"))
-        cmd_str = self.eol
-        ret = self.telnet.read_until(cmd_str.encode("ascii"))
-        ret = ret.decode("utf-8")
-        return ret
-
-    def __disable_all(self):
-        line = "OPR-PORT-SHUTTER::1&&640:123:;"
-        lines = self.__sendcmd(line)
-        return lines
-
-    def __enable_all(self):
-        line = "RLS-PORT-SHUTTER::1&&640:123:;"
-        lines = self.__sendcmd(line)
-        return lines
-
-    def __settimeout(self, timeout=60):
-        return self.__sendcmd("ED-EQPT::TIMEOUT:123:::ADMIN=" + str(timeout) + ";")
-
-    def __clearallconn(self):
-        self.__sendcmd("DLT-PATCH::ALL:123:;")
-
-    def get_inport(self, inx):
-        """
-        Retrieves the mapped Polatis input port number for a given component.
-
-        :param inx: The name of the component.
-        :type inx: str
-
-        :return: The mapped Polatis port number.
-        :rtype: int
-        """
-        # Connect to the MySQL database
-        conn = mysql.connector.connect(
-            host="127.0.0.1", user="testbed", password="mypassword", database="provdb"
-        )
-        cursor = conn.cursor()
-        cursor.execute("SELECT `Out_Port` FROM device_table WHERE polatis_name = %s", (inx,))
-        inp = cursor.fetchone()[0]
-        return inp
-
-    def get_outport(self, outx):
-        """
-        Retrieves the mapped Polatis output port number for a given component.
-
-        :param outx: The name of the component.
-        :type outx: str
-
-        :return: The mapped Polatis port number.
-        :rtype: int
-        """
-        # Connect to the MySQL database
-        conn = mysql.connector.connect(
-            host="127.0.0.1", user="testbed", password="mypassword", database="provdb"
-        )
-        cursor = conn.cursor()
-        cursor.execute("SELECT `In_Port` FROM device_table WHERE polatis_name = %s", (outx,))
-        outp = cursor.fetchone()[0]
-        return outp
-
-    def __disable_port(self, port):
-        line = "OPR-PORT-SHUTTER::" + str(port) + ":123:;"
-        return self.__sendcmd(line)
-
-    def __enable_port(self, port):
-        line = "RLS-PORT-SHUTTER::" + str(port) + ":123:;"
-        return self.__sendcmd(line)
-
-    def __conn(self, inport, outport):
-        line = "ENT-PATCH::" + str(inport) + "," + str(outport) + ":123:;"
-        return self.__sendcmd(line)
-
-    def __disconn(self, inport, outport):
-        line = "DLT-PATCH::" + str(inport) + ":123:;"
-        return self.__sendcmd(line)
-
-    def __fullconn(self, inport, outport):
-        self.__conn(inport, outport)
-
-    def __fulldisconn(self, inport, outport):
-        self.__disconn(inport, outport)
-
-    def logger(self, message):
-        now = datetime.now()
-        with open("/tmp/" + timeStamped("polatis.log"), "a") as outf:
-            outf.write(
-                "%s %s\t%s\t%s\n"
-                % (
-                    now.strftime("%Y/%m/%d %H:%M:%S"),
-                    os.getlogin(),
-                    getpass.getuser(),
-                    message,
-                )
-            )
-
-    def apply_patch_list(self, patch_list):
-
-        """Apply a list of patches to the Polatis switch. The patch list is a list of tuples, where each tuple contains two elements: the input component and the output component.
-
-        :param patch_list: A list of patches, where each patch is a list of ports.
-        :type patch_list: list
-
-        :raises Exception: If patch_list is not a list or if it is empty.
-        :raises Exception: If the port max power is exceeded.
-        :raises Exception: If the ports are not available, or are allocated to other users.
-
-        :return: None
-        :rtype: None
-
-        """
-
-        if not isinstance(patch_list, list):
-            raise Exception("Argument patch_list must be a list of tuples of patches")
-        if len(patch_list) == 0:
-            raise Exception("Argument patch_list must not be empty")
-
-        if not check_patch_owners(patch_list):
-            print("apply_patch_list failed")
-            raise Exception(
-                "apply_patch_list failed, some (or all) ports are not available. Please contact admin."
-            )
-
-        # Connect to the MySQL database
-        conn = mysql.connector.connect(
-            host="127.0.0.1", user="testbed", password="mypassword", database="provdb"
-        )
-        cursor = conn.cursor()
-
-        for patch in patch_list:
-
-            input_comp, output_comp = patch
-
-            # Fetch the 'In' and 'Out' values from the Ports table
-            cursor.execute(
-                "SELECT `Out_Port` FROM device_table WHERE polatis_name = %s", (input_comp,)
-            )
-            inp = cursor.fetchone()[0]
-
-            cursor.execute(
-                "SELECT `In_Port` FROM device_table WHERE polatis_name = %s", (output_comp,)
-            )
-            outp = cursor.fetchone()[0]
-
-            # cursor.execute(
-            #     "SELECT `Max_Inpower` FROM device_table WHERE polatis_name = %s", (input_comp,)
-            # )
-            # max_inpower = cursor.fetchone()
-            # max_inpower = max_inpower[0] if max_inpower else None
-
-            # inpower = self.get_port_power(int(inp))
-            # if max_inpower:
-            #     max_inpower_val = float(max_inpower)
-            # else:
-            #     max_inpower_val = 20.0
-
-            # if inpower > max_inpower_val:
-            #     message = "%s (%s): %.2f dBm > %s (%s): %.2f dBm" % (
-            #         input_comp,
-            #         inp,
-            #         inpower,
-            #         output_comp,
-            #         outp,
-            #         max_inpower_val,
-            #     )
-            #     # self.logger("Patch max power exceeded: %s" % message)
-            #     raise Exception("Patch max power exceeded: %s" % message)
-            # else:
-            self.__conn(inp, outp)
-            time.sleep(1)
-            inpower = self.get_port_power(int(inp))
-            outpower = self.get_port_power(int(outp))
-            data = "%s (%s): %.2f dBm ---> %s (%s): %.2f dBm" % (
-                input_comp,
-                inp,
-                inpower,
-                output_comp,
-                outp,
-                outpower,
-            )
-            print(data)
-                # self.logger("Connect %s" % (data))
-
-        # Close the cursor and connection
-        cursor.close()
-        conn.close()
-
-    def disconnect_devices(self, equipment_1, equipment_2):
-
-        """Disconnect patching between two devices from the Polatis switch.
-
-        :param equipment_1: The name of the first device.
-        :type equipment_1: str
-
-        :param equipment_2: The name of the second device.
-        :type equipment_2: str
-
-        return: None
-        :rtype: None
-
-        raises Exception: If the port names are incorrect, or are allocated to other users.
-        """
-
-        self.disconnect_patch_list([(equipment_1, equipment_2)])
-
-    def disconnect_patch_list(self, patch_list):
-
-        """Disconnect a list of patches from the Polatis switch. The patch list is a list of tuples, where each tuple contains two elements: the input component and the output component.
-
-        :param patch_list: A list of patches, where each patch is a list of ports.
-        :type patch_list: list
-
-        :raises Exception: If patch_list is not a list or if it is empty.
-        :raises Exception: If the port names are incorrect, or are allocated to other users.
-
-        :return: None
-        :rtype: None
-
-        """
-
-        if not isinstance(patch_list, list):
-            raise Exception("Argument patch_list must be a list of tuples of patches")
-        if len(patch_list) == 0:
-            raise Exception("Argument patch_list must not be empty")
-
-        if not check_patch_owners(patch_list):
-            print("apply_patch_list failed")
-            raise Exception(
-                "apply_patch_list failed, some (or all) ports are not available. Please contact admin."
-            )
-
-        # Connect to the MySQL database
-        conn = mysql.connector.connect(
-            host="127.0.0.1", user="testbed", password="mypassword", database="provdb"
-        )
-        cursor = conn.cursor()
-
-        for patch in patch_list:
-
-            input_comp, output_comp = patch
-
-            # Fetch the 'In' and 'Out' values from the Ports table
-            cursor.execute(
-                "SELECT `Out_Port` FROM device_table WHERE polatis_name = %s", (input_comp,)
-            )
-            inp = cursor.fetchone()[0]
-
-            cursor.execute(
-                "SELECT `In_Port` FROM device_table WHERE polatis_name = %s", (output_comp,)
-            )
-            outp = cursor.fetchone()[0]
-
-            self.__disconn(inp, outp)
-            time.sleep(1)
-        # Close the cursor and connection
-        cursor.close()
-        conn.close()
-
-    def release_ports(self, patch_list, username):
-        """ADMIN ONLY: Allocate the ports in the patch list to user/NULL.
-
-        :param patch_list: A list of patches, where each patch is a list of ports.
-        :type patch_list: list
-
-        :param username: The username to allocate the ports to.
-        :type username: str
-
-        :return: None
-        :rtype: None
-
-        """
-
-        with open("/etc/secure_keys/mysql_key.key", "r") as file:
-            lines = file.readlines()
-            admin_user = lines[0].strip()
-            password = lines[1].strip()
-
-        # Connect to the MySQL database
-        conn = mysql.connector.connect(
-            host="127.0.0.1", user=admin_user, password=password, database="provdb"
-        )
-        cursor = conn.cursor()
-
-        for patch in patch_list:
-            for name in patch:
-                if name == "NULL":
-                    continue
-
-                # Set owner to NULL where the owner is the Unix user and the name matches
-                cursor.execute(
-                    f'UPDATE ports_new SET Owner = "{username}" WHERE Name = "{name}"'
-                )
-
-        # Commit the changes
-        conn.commit()
-
-        # Close the cursor and connection
-        cursor.close()
-        conn.close()
-
-    def print_patch_table(self, patch_list):
-
-        """Prints the patch table based on the given patch list.
-
-        :raises Exception: If patch_list is not a list or if it is empty.
-        :raises Exception: If the port max power is exceeded.
-        :raises Exception: If the ports are not available, or are allocated to other users.
-
-        :param patch_list: A list of patches, where each patch is a list of ports.
-        :type patch_list: list
-
-        :return: None
-        :rtype: None
-        """
-
-        if not isinstance(patch_list, list):
-            raise Exception("Argument patch_list must be a list of tuples of patches")
-        if len(patch_list) == 0:
-            raise Exception("Argument patch_list must not be empty")
-        for patch in patch_list:
-            inx, outx = patch
-            inp = self.get_inport(inx)
-            outp = self.get_outport(outx)
-            inpower = self.get_port_power(int(inp))
-            outpower = self.get_port_power(int(outp))
-            data = f"{inx}({inp}): {inpower} dBm ----> {outx}({outp}): {outpower} dBm"
-            print(data)
-
-    def get_patch_table_csv(self, patch_list, filename):
-        """
-        Writes the patch table to a CSV file.
-
-        :param patch_list: A list of patches, where each patch is a list of ports.
-        :type patch_list: list
-
-        :param filename: The location of the CSV file.
-        :type filename: str
-
-        :raises Exception: If patch_list is not a list or if it is empty.
-
-        :return: None
-        :rtype: None
-        """
-        if not isinstance(patch_list, list):
-            raise Exception("Argument patch_list must be a list of tuples of patches")
-        if len(patch_list) == 0:
-            raise Exception("Argument patch_list must not be empty")
-        data = []
-        for patch in patch_list:
-            inx, outx = patch
-            inp = self.get_inport(inx)
-            outp = self.get_outport(outx)
-            inpower = self.get_port_power(int(inp))
-            outpower = self.get_port_power(int(outp))
-            data.append([inx, "Out", inp, inpower])
-            data.append([outx, "In", outp, outpower])
-        with open(filename, "w") as f:
-            writer = csv.writer(f)
-            writer.writerows(data)
-
-    def _get_patch_data(self, patch_list):
-        """Internal method to gather patch data."""
-        if not isinstance(patch_list, list):
-            raise Exception("Argument patch_list must be a list of tuples of patches")
-        if len(patch_list) == 0:
-            raise Exception("Argument patch_list must not be empty")
-        data = []
-        for patch in patch_list:
-            inx, outx = patch
-            inp = self.get_inport(inx)
-            outp = self.get_outport(outx)
-            inpower = self.get_port_power(int(inp))
-            outpower = self.get_port_power(int(outp))
-            data.append([inx, "Out", inp, inpower])
-            data.append([outx, "In", outp, outpower])
-        return data
-
-    def get_patch_table_csv(self, patch_list, filename):
-        data = self._get_patch_data(patch_list)
-        with open(filename, "w") as f:
-            writer = csv.writer(f)
-            writer.writerows(data)
-
-    def get_patch_table_list(self, patch_list):
-        return self._get_patch_data(patch_list)
-
-    def get_NE_type(self):
-        line = "RTRV-NETYPE:::123:;"
-        lines = self.__sendcmd(line)
-        for line in lines.split("\n"):
-            m = re.match(r'\W*"(\S+),(\S+),(\S+),(\S+)"', line)
-            if m:
-                print(m.group(1), m.group(2), m.group(3), m.group(4))
-
-    def get_all_patch(self):
-        line = "RTRV-PATCH:::123:;"
-        lines = self.__sendcmd(line)
-        for line in lines.split("\n"):
-            m = re.match(r'\W*"(\d+),(\d+)"', line)
-            if m:
-                self.patch[int(m.group(1))] = int(m.group(2))
-        return
-
-    def get_all_atten(self):
-        line = "RTRV-PORT-ATTEN::1&&640:123:;"
-        lines = self.__sendcmd(line)
-        print(lines)
-
-    def get_all_labels(self):
-        line = "RTRV-PORT-LABEL::1&&640:123:;"
-        lines = self.__sendcmd(line)
-        for line in lines.split("\n"):
-            m = re.match(r'\W*"(\d+):(\S+)"', line)
-            if m:
-                self.label[int(m.group(1))] = m.group(2)
-        print(self.label)
-        return
-
-    def get_all_shutter(self):
-        line = "RTRV-PORT-SHUTTER::1&&640:123:;"
-        lines = self.__sendcmd(line)
-        for line in lines.split("\n"):
-            m = re.match(r'\W*"(\d+):(\S+)"', line)
-            if m:
-                self.shutter[int(m.group(1))] = m.group(2)
-        return
-
-    def get_all_pmon(self):
-        line = "RTRV-PORT-PMON::1&&640:123:;"
-        lines = self.__sendcmd(line)
-        for line in lines.split("\n"):
-            m = re.match(r'\W*"(\d+):(\S+),(\S+),(\S+)"', line)
-            if m:
-                self.wavelength[int(m.group(1))] = float(m.group(2))
-                self.offset[int(m.group(1))] = float(m.group(3))
-                self.atime[int(m.group(1))] = float(m.group(4))
-        line = "RTRV-EQPT::PMON:123:::PARAMETER=CONFIG;"
-        lines = self.__sendcmd(line)
-        for line in lines.split("\n"):
-            m = re.match(r'\W*"PMON::PORT=(\d+),MODE=(\S+)"', line)
-            if m:
-                self.monmode[int(m.group(1))] = m.group(2)
-        return
-
-    def get_all_power(self):
-        line = "RTRV-PORT-POWER::1&&640:123:;"
-        lines = self.__sendcmd(line)
-        for line in lines.split("\n"):
-            m = re.match(r'\W*"(\d+):(\S+)"', line)
-            if m:
-                self.power[int(m.group(1))] = float(m.group(2))
-        return
-
-    def test_all_power(self):
-        self.get_all_power()
-        while True:
-            line = "RTRV-PORT-POWER::1&&640:123:;"
-            lines = self.__sendcmd(line)
-            for line in lines.split("\n"):
-                m = re.match(r'\W*"(\d+):(\S+)"', line)
-                if m:
-                    port = int(m.group(1))
-                    power = float(m.group(2))
-                    if abs(self.power[port] - power) > 3:
-                        if power > self.power[port]:
-                            transit = "Up"
-                        else:
-                            transit = "Down"
-                        print(
-                            "%s: %d %.2f -> %.2f"
-                            % (transit, port, self.power[port], power)
-                        )
-                    self.power[port] = float(power)
-
-    def get_port_power(self, port):
-        """Get the power of a port. The ports must be the absolute port number, not the component name.
-
-        :param port: The port number.
-        :type port: int
-
-        :return: The power of the port.
-        :rtype: float
-        """
-        line = "RTRV-PORT-POWER::%d:123:;" % port
-        lines = self.__sendcmd(line)
-        for line in lines.split("\n"):
-            m = re.match(r'\W*"(\d+):(\S+)"', line)
-            if m:
-                return float(m.group(2))
-        return -99.99
-
-    def get_device_power(self, equipment, io):
-        """Get the input/output power of a device.
-
-        :param port: The name of the device
-        :type port: str
-
-        :param io: The input/output port of the device, either "in" or "out".
-        :type io: str
-
-        :return: The power of the port.
-        :rtype: float
-        """
-        if io == "in":
-            port = int(self.get_outport(equipment))
-        elif io == "out":
-            port = int(self.get_inport(equipment))
-        return self.get_port_power(port)
-
-    def getall(self):
-        self.get_all_patch()
-        self.get_all_shutter()
-        self.get_all_pmon()
-        self.get_all_power()
-
-    def report_all(self):
-        print("REPORTING FUNCTION CALLED - 1")
-        return_dict = {}
-        for i in sorted(self.power.keys()):
-            try:
-                patch = self.patch.get(i, 0)
-                shutter = self.shutter.get(i, "")
-                monmode = self.monmode.get(i, "")
-                wavelength = self.wavelength.get(i, 0.0)
-                offset = self.offset.get(i, 0.0)
-                atime = self.atime.get(i, 0.0)
-                power = self.power.get(i, 0.0)
-            except Exception as e:
-                print(f"The key {i} failed: {e}")
-            # print(i, patch, shutter, monmode, wavelength, offset, atime, power)
-            return_dict[i] = [patch, shutter, monmode, wavelength, offset, atime, power]
-        return return_dict
+"""
+Shim module for the new NETCONF-based Polatis implementation.
+This module exports the 'Polatis' class from the new implementation.
+It also exports 'PolatisNetconf' for backward compatibility.
+"""
+
+try:
+    from .polatis.polatis import Polatis, PolatisNetconf
+except ImportError:
+    # If the sub-package cannot be imported (e.g. missing dependencies), re-raise.
+    raise
+
+__all__ = ["Polatis", "PolatisNetconf"]
diff --git a/polatis/__init__.py b/polatis/__init__.py
new file mode 100644
index 0000000..7d36ab4
--- /dev/null
+++ b/polatis/__init__.py
@@ -0,0 +1,7 @@
+from .polatis import PolatisNetconf, Polatis
+
+__all__ = [
+    "PolatisNetconf",
+    "Polatis"
+    ]
+
diff --git a/polatis/polatis.py b/polatis/polatis.py
new file mode 100644
index 0000000..29467ea
--- /dev/null
+++ b/polatis/polatis.py
@@ -0,0 +1,784 @@
+"""
+Unified Polatis API (NETCONF + DB) with legacy-compatible interface.
+
+Primary class:
+    Polatis          – unified API
+Backward-compatible alias:
+    PolatisNetconf   – kept for existing imports
+
+Features:
+  - Power monitoring          (opm-power)
+  - VOA control               (voa)
+  - OPM configuration         (opm-config)
+  - Cross-connect management  (cross-connects)
+  - Port shutter control      (polatis-switch RPC)
+  - DB-backed device mapping  (device_table, ports_new)
+  - Legacy method names kept as aliases where possible
+
+Unsupported legacy telnet-only behaviours raise NotImplementedError.
+"""
+
+import logging
+from typing import Dict, List, Tuple, Optional
+
+import mysql.connector
+from ncclient import manager
+from lxml import etree
+from tcdona3.utils import check_patch_owners
+
+logger = logging.getLogger(__name__)
+
+OPSW_NS = "http://www.polatis.com/yang/optical-switch"
+PLTS_NS = "http://www.polatis.com/yang/polatis-switch"
+NC_NS = "urn:ietf:params:xml:ns:netconf:base:1.0"
+
+OPSW = f"{{{OPSW_NS}}}"
+PLTS = f"{{{PLTS_NS}}}"
+NC = f"{{{NC_NS}}}"
+
+
+class Polatis:
+    """
+    Unified Polatis API using NETCONF + MySQL, with compatibility
+    to the legacy telnet-based Polatis class.
+
+    - Connection management via NETCONF
+    - DB used for logical device <-> port mappings and ownership
+    """
+
+    # ------------------------------------------------------------------
+    # INIT / LOGIN / LOGOUT (legacy-compatible surface)
+    # ------------------------------------------------------------------
+
+    def __init__(
+        self,
+        host: str = "10.10.10.28",
+        port: int = 830,
+        username: str = "admin",
+        password: str = "root",
+        db_host: str = "127.0.0.1",
+        db_user: str = "testbed",
+        db_pass: str = "mypassword",
+        db_name: str = "provdb",
+    ):
+        """
+        Parameters
+        ----------
+        host : str
+            Switch management IP.
+        port : int
+            NETCONF port (Polatis default: 830).
+        username : str
+            NETCONF username.
+        password : str
+            NETCONF password.
+        db_host, db_user, db_pass, db_name :
+            MySQL connection parameters for provisioning database.
+        """
+        self.host = host
+        self.port = port
+        self.username = username
+        self.password = password
+
+        self.db_host = db_host
+        self.db_user = db_user
+        self.db_pass = db_pass
+        self.db_name = db_name
+
+        self._mgr: Optional[manager.Manager] = None
+
+    # Legacy public API compatibility
+    def login(self):
+        """Legacy method name – mapped to NETCONF connect()."""
+        self.connect()
+
+    def logout(self):
+        """Legacy method name – mapped to NETCONF close()."""
+        self.close()
+
+    def __del__(self):
+        try:
+            self.close()
+        except Exception:
+            pass
+
+    # ------------------------------------------------------------------
+    # NETCONF connection helpers
+    # ------------------------------------------------------------------
+
+    def connect(self):
+        """Ensure a NETCONF session is established."""
+        if self._mgr is not None and self._mgr.connected:
+            return
+
+        logger.info("Connecting NETCONF session to %s:%s", self.host, self.port)
+        self._mgr = manager.connect(
+            host=self.host,
+            port=self.port,
+            username=self.username,
+            password=self.password,
+            hostkey_verify=False,
+            allow_agent=False,
+            look_for_keys=False,
+            timeout=30,
+        )
+        logger.info("NETCONF session established")
+
+    def close(self):
+        """Close NETCONF session if open."""
+        if self._mgr is not None:
+            try:
+                if self._mgr.connected:
+                    logger.info("Closing NETCONF session")
+                    self._mgr.close_session()
+            except Exception:
+                logger.exception("Error while closing NETCONF session")
+        self._mgr = None
+
+    def __enter__(self) -> "Polatis":
+        self.connect()
+        return self
+
+    def __exit__(self, exc_type, exc, tb):
+        self.close()
+
+    @property
+    def mgr(self) -> manager.Manager:
+        """Return active ncclient Manager, reconnecting if needed."""
+        if self._mgr is None or not self._mgr.connected:
+            self.connect()
+        return self._mgr
+
+    # ------------------------------------------------------------------
+    # Internal helpers
+    # ------------------------------------------------------------------
+
+    def _subtree_get(self, xml_subtree: str) -> etree._Element:
+        """Perform NETCONF <get> with subtree filter; return <data> element."""
+        logger.debug("NETCONF GET filter:\n%s", xml_subtree)
+        reply = self.mgr.get(filter=("subtree", xml_subtree))
+        data_ele = reply.data_ele
+        logger.debug(
+            "NETCONF GET response:\n%s",
+            etree.tostring(data_ele, pretty_print=True).decode(errors="ignore"),
+        )
+        return data_ele
+
+    def _edit(self, config_xml: str):
+        """Perform NETCONF <edit-config> on running datastore."""
+        logger.info("NETCONF edit-config:\n%s", config_xml)
+        try:
+            reply = self.mgr.edit_config(target="running", config=config_xml)
+            logger.debug("edit-config reply: %s", reply)
+        except Exception:
+            logger.exception("edit-config failed")
+            raise
+
+    def _rpc(self, rpc_xml: str):
+        """Send a raw NETCONF <rpc> (used for shutter RPCs)."""
+        logger.info("NETCONF RPC:\n%s", rpc_xml)
+        try:
+            return self.mgr.dispatch(etree.fromstring(rpc_xml))
+        except Exception:
+            logger.exception("RPC failed")
+            raise
+
+    # ------------------------------------------------------------------
+    # DB Helpers
+    # ------------------------------------------------------------------
+
+    def _db(self):
+        """Return a new MySQL connection."""
+        return mysql.connector.connect(
+            host=self.db_host,
+            user=self.db_user,
+            password=self.db_pass,
+            database=self.db_name,
+        )
+
+    # ------------------------------------------------------------------
+    # Power monitoring (opm-power)
+    # ------------------------------------------------------------------
+
+    def get_port_power(self, port: int) -> float:
+        """
+        Get optical power (dBm) for a single port using /opm-power.
+        """
+        subtree = f"""
+        <opm-power xmlns="{OPSW_NS}">
+          <port>
+            <port-id>{port}</port-id>
+            <power/>
+          </port>
+        </opm-power>
+        """
+        data = self._subtree_get(subtree)
+        pwr_elem = data.find(
+            f".//{OPSW}opm-power/{OPSW}port[{OPSW}port-id='{port}']/{OPSW}power"
+        )
+        if pwr_elem is None or pwr_elem.text is None:
+            raise KeyError(f"No power reading for port {port}")
+        power = float(pwr_elem.text)
+        logger.info("Port %s power = %.2f dBm", port, power)
+        return power
+
+    def get_all_power(self) -> Dict[int, float]:
+        """
+        Get power for all ports with OPM entries.
+        """
+        subtree = f"""
+        <opm-power xmlns="{OPSW_NS}">
+          <port>
+            <port-id/>
+            <power/>
+          </port>
+        </opm-power>
+        """
+        data = self._subtree_get(subtree)
+        result: Dict[int, float] = {}
+        for port_elem in data.findall(f".//{OPSW}opm-power/{OPSW}port"):
+            pid = port_elem.find(f"{OPSW}port-id")
+            pwr = port_elem.find(f"{OPSW}power")
+            if pid is None or pid.text is None:
+                continue
+            if pwr is None or pwr.text is None:
+                continue
+            try:
+                pid_val = int(pid.text)
+                pwr_val = float(pwr.text)
+            except ValueError:
+                continue
+            result[pid_val] = pwr_val
+        logger.info("Retrieved power for %d ports", len(result))
+        return result
+
+    # Legacy PMON state – not representable via YANG
+    def get_all_pmon(self):
+        raise NotImplementedError(
+            "PMON details (monmode, averaging time, full calibration state) "
+            "are not exposed via Polatis YANG models."
+        )
+
+    # ------------------------------------------------------------------
+    # OPM config (wavelength / offset) – opm-config
+    # ------------------------------------------------------------------
+
+    def set_opm_config(
+        self,
+        port: int,
+        wavelength_nm: Optional[float] = None,
+        offset_db: Optional[float] = None,
+    ):
+        """
+        Set OPM configuration (wavelength, offset) for a port.
+        """
+        if wavelength_nm is None and offset_db is None:
+            logger.info("set_opm_config called with no changes; skipping")
+            return
+
+        parts = [
+            f'<opm-config xmlns="{OPSW_NS}"><port>',
+            f"<port-id>{port}</port-id>",
+        ]
+        if wavelength_nm is not None:
+            parts.append(f"<wavelength>{float(wavelength_nm):.2f}</wavelength>")
+        if offset_db is not None:
+            parts.append(f"<offset>{float(offset_db):.2f}</offset>")
+        parts.append("</port></opm-config>")
+
+        cfg = f'<nc:config xmlns:nc="{NC_NS}">' + "".join(parts) + "</nc:config>"
+        self._edit(cfg)
+
+    # ------------------------------------------------------------------
+    # VOA (voa)
+    # ------------------------------------------------------------------
+
+    def get_all_atten(self) -> Dict[int, float]:
+        """
+        Return VOA attenuation levels for all ports that have one set.
+        """
+        subtree = f"""
+        <voa xmlns="{OPSW_NS}">
+          <port>
+            <port-id/>
+            <atten-level/>
+          </port>
+        </voa>
+        """
+        data = self._subtree_get(subtree)
+        out: Dict[int, float] = {}
+        for port_elem in data.findall(f".//{OPSW}voa/{OPSW}port"):
+            pid = port_elem.find(f"{OPSW}port-id")
+            lvl = port_elem.find(f"{OPSW}atten-level")
+            if pid is None or pid.text is None:
+                continue
+            if lvl is None or lvl.text is None:
+                continue
+            try:
+                out[int(pid.text)] = float(lvl.text)
+            except ValueError:
+                continue
+        return out
+
+    def set_voa(
+        self,
+        port: int,
+        mode: str,
+        atten_level: Optional[float] = None,
+        reference_port: Optional[int] = None,
+    ):
+        """
+        Configure VOA for a given port.
+
+        mode must be one of:
+          VOA_MODE_NONE, VOA_MODE_RELATIVE, VOA_MODE_ABSOLUTE,
+          VOA_MODE_CONVERGED, VOA_MODE_MAXIMUM, VOA_MODE_FIXED
+        """
+        valid_modes = {
+            "VOA_MODE_NONE",
+            "VOA_MODE_RELATIVE",
+            "VOA_MODE_ABSOLUTE",
+            "VOA_MODE_CONVERGED",
+            "VOA_MODE_MAXIMUM",
+            "VOA_MODE_FIXED",
+        }
+        if mode not in valid_modes:
+            raise ValueError(f"Invalid VOA mode {mode!r}")
+
+        parts = [
+            f'<voa xmlns="{OPSW_NS}"><port>',
+            f"<port-id>{port}</port-id>",
+            f"<atten-mode>{mode}</atten-mode>",
+        ]
+        if atten_level is not None:
+            parts.append(f"<atten-level>{float(atten_level):.2f}</atten-level>")
+        if reference_port is not None:
+            parts.append(f"<reference-port>{reference_port}</reference-port>")
+        parts.append("</port></voa>")
+
+        cfg = f'<nc:config xmlns:nc="{NC_NS}">' + "".join(parts) + "</nc:config>"
+        self._edit(cfg)
+
+    # ------------------------------------------------------------------
+    # Port labels / status (port-config)
+    # ------------------------------------------------------------------
+
+    def get_all_labels(self) -> Dict[int, str]:
+        """
+        Return dict[port-id] -> label.
+        """
+        subtree = f"""
+        <port-config xmlns="{OPSW_NS}">
+          <port>
+            <port-id/>
+            <label/>
+          </port>
+        </port-config>
+        """
+        data = self._subtree_get(subtree)
+        out: Dict[int, str] = {}
+        for port_elem in data.findall(f".//{OPSW}port-config/{OPSW}port"):
+            pid = port_elem.find(f"{OPSW}port-id")
+            lbl = port_elem.find(f"{OPSW}label")
+            if pid is None or pid.text is None:
+                continue
+            if lbl is None or lbl.text is None:
+                continue
+            out[int(pid.text)] = lbl.text
+        return out
+
+    def get_port_status(self, port: int) -> Optional[str]:
+        """
+        Return status string for a port (ENABLED / DISABLED / FAILED / etc.).
+        """
+        subtree = f"""
+        <port-config xmlns="{OPSW_NS}">
+          <port>
+            <port-id>{port}</port-id>
+            <status/>
+          </port>
+        </port-config>
+        """
+        data = self._subtree_get(subtree)
+        status_elem = data.find(
+            f".//{OPSW}port-config/{OPSW}port[{OPSW}port-id='{port}']/{OPSW}status"
+        )
+        return status_elem.text if status_elem is not None else None
+
+    # ------------------------------------------------------------------
+    # Shutter Control (polatis-switch RPC)
+    # ------------------------------------------------------------------
+
+    def enable_port(self, port: int):
+        """
+        Enable a port shutter via polatis-switch RPC.
+        """
+        rpc = f"""
+        <port-shutter-set-state xmlns="{PLTS_NS}">
+          <port-enab>{port}</port-enab>
+        </port-shutter-set-state>
+        """
+        self._rpc(rpc)
+
+    def disable_port(self, port: int):
+        """
+        Disable a port shutter via polatis-switch RPC.
+        """
+        rpc = f"""
+        <port-shutter-set-state xmlns="{PLTS_NS}">
+          <port-disab>{port}</port-disab>
+        </port-shutter-set-state>
+        """
+        self._rpc(rpc)
+
+    # Legacy private names
+    __enable_port = enable_port
+    __disable_port = disable_port
+
+    def get_all_shutter(self):
+        """
+        Legacy method; shutter state is not exposed in YANG.
+        """
+        raise NotImplementedError(
+            "Shutter state is not exposed via the Polatis YANG models."
+        )
+
+    def __disable_all(self):
+        raise NotImplementedError("No YANG support for disable_all().")
+
+    def __enable_all(self):
+        raise NotImplementedError("No YANG support for enable_all().")
+
+    # ------------------------------------------------------------------
+    # Cross-connects (cross-connects)
+    # ------------------------------------------------------------------
+
+    def create_cross_connect(self, ingress: int, egress: int):
+        """
+        Create a cross-connect ingress -> egress.
+        """
+        cfg = f"""
+        <nc:config xmlns:nc="{NC_NS}">
+          <cross-connects xmlns="{OPSW_NS}">
+            <pair>
+              <ingress>{ingress}</ingress>
+              <egress>{egress}</egress>
+            </pair>
+          </cross-connects>
+        </nc:config>
+        """
+        self._edit(cfg)
+
+    def delete_cross_connect(self, ingress: int):
+        """
+        Delete a cross-connect identified by ingress port.
+        """
+        cfg = f"""
+        <nc:config xmlns:nc="{NC_NS}">
+          <cross-connects xmlns="{OPSW_NS}">
+            <pair nc:operation="delete">
+              <ingress>{ingress}</ingress>
+            </pair>
+          </cross-connects>
+        </nc:config>
+        """
+        self._edit(cfg)
+
+    # Legacy aliases
+    __conn = create_cross_connect
+    __disconn = delete_cross_connect
+    __fullconn = create_cross_connect
+    __fulldisconn = delete_cross_connect
+
+    def get_cross_connects(self) -> List[Tuple[int, int]]:
+        """
+        Return a list of (ingress, egress) tuples for all cross-connects.
+        """
+        subtree = f"""
+        <cross-connects xmlns="{OPSW_NS}">
+          <pair>
+            <ingress/>
+            <egress/>
+          </pair>
+        </cross-connects>
+        """
+        data = self._subtree_get(subtree)
+        pairs: List[Tuple[int, int]] = []
+        for pair_elem in data.findall(f".//{OPSW}cross-connects/{OPSW}pair"):
+            i = pair_elem.find(f"{OPSW}ingress")
+            e = pair_elem.find(f"{OPSW}egress")
+            if i is None or i.text is None:
+                continue
+            if e is None or e.text is None:
+                continue
+            try:
+                ingress = int(i.text)
+                egress = int(e.text)
+            except ValueError:
+                continue
+            pairs.append((ingress, egress))
+        return pairs
+
+    # Legacy name
+    get_all_patch = get_cross_connects
+
+    def connection_exists(self, ingress: int, egress: Optional[int] = None) -> bool:
+        """
+        Check if a cross-connect exists for ingress (and optionally egress).
+        """
+        if egress is None:
+            subtree = f"""
+            <cross-connects xmlns="{OPSW_NS}">
+              <pair>
+                <ingress>{ingress}</ingress>
+                <egress/>
+              </pair>
+            </cross-connects>
+            """
+        else:
+            subtree = f"""
+            <cross-connects xmlns="{OPSW_NS}">
+              <pair>
+                <ingress>{ingress}</ingress>
+                <egress>{egress}</egress>
+              </pair>
+            </cross-connects>
+            """
+
+        data = self._subtree_get(subtree)
+        pairs = data.findall(f".//{OPSW}pair")
+        if not pairs:
+            return False
+
+        for p in pairs:
+            i = p.find(f"{OPSW}ingress")
+            e = p.find(f"{OPSW}egress")
+            if i is None or i.text is None:
+                continue
+            try:
+                i_val = int(i.text)
+            except ValueError:
+                continue
+            if i_val != ingress:
+                continue
+            if egress is None:
+                return True
+            if e is None or e.text is None:
+                continue
+            try:
+                e_val = int(e.text)
+            except ValueError:
+                continue
+            if e_val == egress:
+                return True
+        return False
+
+    # ------------------------------------------------------------------
+    # DB-based device mapping / ownership
+    # ------------------------------------------------------------------
+
+    def get_inport(self, inx: str) -> int:
+        """
+        Map logical device name -> Polatis OUT port (legacy behaviour).
+        """
+        db = self._db()
+        cur = db.cursor()
+        cur.execute(
+            "SELECT Out_Port FROM device_table WHERE polatis_name=%s", (inx,)
+        )
+        row = cur.fetchone()
+        cur.close()
+        db.close()
+        if not row:
+            raise KeyError(f"No device_table entry for {inx}")
+        return int(row[0])
+
+    def get_outport(self, outx: str) -> int:
+        """
+        Map logical device name -> Polatis IN port (legacy behaviour).
+        """
+        db = self._db()
+        cur = db.cursor()
+        cur.execute(
+            "SELECT In_Port FROM device_table WHERE polatis_name=%s", (outx,)
+        )
+        row = cur.fetchone()
+        cur.close()
+        db.close()
+        if not row:
+            raise KeyError(f"No device_table entry for {outx}")
+        return int(row[0])
+
+    def get_device_power(self, equipment: str, io: str) -> float:
+        """
+        Get power for device input or output side (legacy semantics).
+        """
+        if io == "in":
+            port = self.get_outport(equipment)
+        elif io == "out":
+            port = self.get_inport(equipment)
+        else:
+            raise ValueError("io must be 'in' or 'out'")
+        return self.get_port_power(port)
+
+    def release_ports(self, patch_list, username: str):
+        """
+        ADMIN ONLY: update ports_new.Owner for all names in patch_list.
+        """
+        db = self._db()
+        cur = db.cursor()
+        for patch in patch_list:
+            for name in patch:
+                if name == "NULL":
+                    continue
+                cur.execute(
+                    "UPDATE ports_new SET Owner=%s WHERE Name=%s",
+                    (username, name),
+                )
+        db.commit()
+        cur.close()
+        db.close()
+
+    # ------------------------------------------------------------------
+    # Patch application (batched edit-config)
+    # ------------------------------------------------------------------
+
+    def apply_patch_list(self, patch_list: List[Tuple[str, str]]):
+        """
+        Apply a list of device pairs using DB mapping + NETCONF.
+
+        patch_list is a list of (input_device_name, output_device_name).
+        """
+        if not isinstance(patch_list, list) or not patch_list:
+            raise Exception("patch_list must be a non-empty list of tuples")
+
+        if not check_patch_owners(patch_list):
+            raise Exception(
+                "apply_patch_list failed, some (or all) ports are not available. Please contact admin."
+            )
+
+        pairs_xml: List[str] = []
+        for (input_comp, output_comp) in patch_list:
+            inp = self.get_inport(input_comp)
+            outp = self.get_outport(output_comp)
+            pairs_xml.append(
+                f"<pair><ingress>{inp}</ingress><egress>{outp}</egress></pair>"
+            )
+
+        cfg = (
+            f'<nc:config xmlns:nc="{NC_NS}">'
+            f'<cross-connects xmlns="{OPSW_NS}">'
+            + "".join(pairs_xml)
+            + "</cross-connects></nc:config>"
+        )
+        self._edit(cfg)
+
+    def disconnect_devices(self, equipment_1: str, equipment_2: str):
+        """
+        Legacy helper – disconnect a single device pair.
+        """
+        self.disconnect_patch_list([(equipment_1, equipment_2)])
+
+    def disconnect_patch_list(self, patch_list: List[Tuple[str, str]]):
+        """
+        Disconnect a list of device pairs using DB + NETCONF.
+        """
+        if not isinstance(patch_list, list) or not patch_list:
+            raise Exception("patch_list must be a non-empty list of tuples")
+
+        if not check_patch_owners(patch_list):
+            raise Exception(
+                "disconnect_patch_list failed, some (or all) ports are not available. Please contact admin."
+            )
+
+        pairs_xml: List[str] = []
+        for (input_comp, output_comp) in patch_list:
+            # legacy semantics: delete by ingress only
+            inp = self.get_inport(input_comp)
+            pairs_xml.append(
+                f'<pair nc:operation="delete"><ingress>{inp}</ingress></pair>'
+            )
+
+        cfg = (
+            f'<nc:config xmlns:nc="{NC_NS}">'
+            f'<cross-connects xmlns="{OPSW_NS}">'
+            + "".join(pairs_xml)
+            + "</cross-connects></nc:config>"
+        )
+        self._edit(cfg)
+
+    # ------------------------------------------------------------------
+    # Patch table utilities (for reporting / CSV)
+    # ------------------------------------------------------------------
+
+    def _get_patch_data(self, patch_list: List[Tuple[str, str]]):
+        """
+        Internal helper: return list rows of:
+        [device_name, 'Out'/'In', port_number, power_dBm]
+        """
+        if not isinstance(patch_list, list) or not patch_list:
+            raise Exception("patch_list must be a non-empty list of tuples")
+
+        rows: List[List] = []
+        for (inx, outx) in patch_list:
+            inp = self.get_inport(inx)
+            outp = self.get_outport(outx)
+            inpower = self.get_port_power(inp)
+            outpower = self.get_port_power(outp)
+            rows.append([inx, "Out", inp, inpower])
+            rows.append([outx, "In", outp, outpower])
+        return rows
+
+    def get_patch_table_list(self, patch_list: List[Tuple[str, str]]):
+        return self._get_patch_data(patch_list)
+
+    def get_patch_table_csv(self, patch_list: List[Tuple[str, str]], filename: str):
+        import csv
+
+        rows = self._get_patch_data(patch_list)
+        with open(filename, "w") as f:
+            writer = csv.writer(f)
+            writer.writerows(rows)
+
+    def print_patch_table(self, patch_list: List[Tuple[str, str]]):
+        if not isinstance(patch_list, list) or not patch_list:
+            raise Exception("patch_list must be a non-empty list of tuples")
+
+        for patch in patch_list:
+            inx, outx = patch
+            inp = self.get_inport(inx)
+            outp = self.get_outport(outx)
+            inpower = self.get_port_power(int(inp))
+            outpower = self.get_port_power(int(outp))
+            data = f"{inx}({inp}): {inpower:.2f} dBm ----> {outx}({outp}): {outpower:.2f} dBm"
+            print(data)
+
+    # ------------------------------------------------------------------
+    # Legacy methods with no clean NETCONF equivalent
+    # ------------------------------------------------------------------
+
+    def __sendcmd(self, line):
+        raise NotImplementedError("Legacy telnet __sendcmd() is not supported.")
+
+    def __settimeout(self, timeout=60):
+        raise NotImplementedError("No NETCONF equivalent for settimeout().")
+
+    def __clearallconn(self):
+        raise NotImplementedError("No NETCONF 'clear all connections' primitive.")
+
+    def get_NE_type(self):
+        raise NotImplementedError("NE type is not exposed via NETCONF YANG models.")
+
+    def test_all_power(self):
+        raise NotImplementedError("Continuous polling loop not provided here.")
+
+    def getall(self):
+        raise NotImplementedError("Legacy aggregate getall() not implemented.")
+
+    def report_all(self):
+        raise NotImplementedError("Legacy report_all() not implemented.")
+
+
+# Backward-compatible alias
+PolatisNetconf = Polatis
+
diff --git a/polatis/polatis_old.py b/polatis/polatis_old.py
new file mode 100755
index 0000000..3897352
--- /dev/null
+++ b/polatis/polatis_old.py
@@ -0,0 +1,595 @@
+import telnetlib
+import re
+import pandas as pd
+import time
+import os
+import getpass
+from datetime import datetime
+import sqlite3
+import csv
+import mysql.connector
+from tcdona3.utils import check_patch_owners
+
+
+def timeStamped(fname, fmt="%Y-%m-%d_{fname}"):
+    return datetime.now().strftime(fmt).format(fname=fname)
+
+
+class Polatis:
+
+    """Polatis class to interact with Polatis switch using telnet
+
+    :param host: The IP address of the Polatis switch, defaults to 10.10.10.28"
+    :type host: str
+
+    :param port: The port number of the Polatis switch, defaults to 3082
+    :type port: str
+
+    :return: None
+    :rtype: None
+    """
+
+    def __init__(self, host="10.10.10.28", port="3082"):
+        """Constructor method"""
+        self.telnet = telnetlib.Telnet(host, port)
+        self.eol = ";"
+        self.patch = {}
+        self.shutter = {}
+        self.monmode = {}
+        self.wavelength = {}
+        self.offset = {}
+        self.atime = {}
+        self.power = {}
+        self.label = {}
+
+    def __del__(self):
+        pass
+
+    def login(self):
+        """Login to the Polatis switch
+
+        :return: None
+        :rtype: None
+        """
+        return self.__sendcmd("ACT-USER::root:123::root;")
+
+    def logout(self):
+        #        print self.telnet.read_all()
+        self.__sendcmd("CANC-USER::root:123:;")
+        self.telnet.close()
+
+    def __sendcmd(self, line):
+        #        print "sending " + line
+        cmd_str = "%s\n" % line
+        self.telnet.write(cmd_str.encode("ascii"))
+        cmd_str = self.eol
+        ret = self.telnet.read_until(cmd_str.encode("ascii"))
+        ret = ret.decode("utf-8")
+        return ret
+
+    def __disable_all(self):
+        line = "OPR-PORT-SHUTTER::1&&640:123:;"
+        lines = self.__sendcmd(line)
+        return lines
+
+    def __enable_all(self):
+        line = "RLS-PORT-SHUTTER::1&&640:123:;"
+        lines = self.__sendcmd(line)
+        return lines
+
+    def __settimeout(self, timeout=60):
+        return self.__sendcmd("ED-EQPT::TIMEOUT:123:::ADMIN=" + str(timeout) + ";")
+
+    def __clearallconn(self):
+        self.__sendcmd("DLT-PATCH::ALL:123:;")
+
+    def get_inport(self, inx):
+        """
+        Retrieves the mapped Polatis input port number for a given component.
+
+        :param inx: The name of the component.
+        :type inx: str
+
+        :return: The mapped Polatis port number.
+        :rtype: int
+        """
+        # Connect to the MySQL database
+        conn = mysql.connector.connect(
+            host="127.0.0.1", user="testbed", password="mypassword", database="provdb"
+        )
+        cursor = conn.cursor()
+        cursor.execute("SELECT `Out_Port` FROM device_table WHERE polatis_name = %s", (inx,))
+        inp = cursor.fetchone()[0]
+        return inp
+
+    def get_outport(self, outx):
+        """
+        Retrieves the mapped Polatis output port number for a given component.
+
+        :param outx: The name of the component.
+        :type outx: str
+
+        :return: The mapped Polatis port number.
+        :rtype: int
+        """
+        # Connect to the MySQL database
+        conn = mysql.connector.connect(
+            host="127.0.0.1", user="testbed", password="mypassword", database="provdb"
+        )
+        cursor = conn.cursor()
+        cursor.execute("SELECT `In_Port` FROM device_table WHERE polatis_name = %s", (outx,))
+        outp = cursor.fetchone()[0]
+        return outp
+
+    def __disable_port(self, port):
+        line = "OPR-PORT-SHUTTER::" + str(port) + ":123:;"
+        return self.__sendcmd(line)
+
+    def __enable_port(self, port):
+        line = "RLS-PORT-SHUTTER::" + str(port) + ":123:;"
+        return self.__sendcmd(line)
+
+    def __conn(self, inport, outport):
+        line = "ENT-PATCH::" + str(inport) + "," + str(outport) + ":123:;"
+        return self.__sendcmd(line)
+
+    def __disconn(self, inport, outport):
+        line = "DLT-PATCH::" + str(inport) + ":123:;"
+        return self.__sendcmd(line)
+
+    def __fullconn(self, inport, outport):
+        self.__conn(inport, outport)
+
+    def __fulldisconn(self, inport, outport):
+        self.__disconn(inport, outport)
+
+    def logger(self, message):
+        now = datetime.now()
+        with open("/tmp/" + timeStamped("polatis.log"), "a") as outf:
+            outf.write(
+                "%s %s\t%s\t%s\n"
+                % (
+                    now.strftime("%Y/%m/%d %H:%M:%S"),
+                    os.getlogin(),
+                    getpass.getuser(),
+                    message,
+                )
+            )
+
+    def apply_patch_list(self, patch_list):
+
+        """Apply a list of patches to the Polatis switch. The patch list is a list of tuples, where each tuple contains two elements: the input component and the output component.
+
+        :param patch_list: A list of patches, where each patch is a list of ports.
+        :type patch_list: list
+
+        :raises Exception: If patch_list is not a list or if it is empty.
+        :raises Exception: If the port max power is exceeded.
+        :raises Exception: If the ports are not available, or are allocated to other users.
+
+        :return: None
+        :rtype: None
+
+        """
+
+        if not isinstance(patch_list, list):
+            raise Exception("Argument patch_list must be a list of tuples of patches")
+        if len(patch_list) == 0:
+            raise Exception("Argument patch_list must not be empty")
+
+        if not check_patch_owners(patch_list):
+            print("apply_patch_list failed")
+            raise Exception(
+                "apply_patch_list failed, some (or all) ports are not available. Please contact admin."
+            )
+
+        # Connect to the MySQL database
+        conn = mysql.connector.connect(
+            host="127.0.0.1", user="testbed", password="mypassword", database="provdb"
+        )
+        cursor = conn.cursor()
+
+        for patch in patch_list:
+
+            input_comp, output_comp = patch
+
+            # Fetch the 'In' and 'Out' values from the Ports table
+            cursor.execute(
+                "SELECT `Out_Port` FROM device_table WHERE polatis_name = %s", (input_comp,)
+            )
+            inp = cursor.fetchone()[0]
+
+            cursor.execute(
+                "SELECT `In_Port` FROM device_table WHERE polatis_name = %s", (output_comp,)
+            )
+            outp = cursor.fetchone()[0]
+
+            # cursor.execute(
+            #     "SELECT `Max_Inpower` FROM device_table WHERE polatis_name = %s", (input_comp,)
+            # )
+            # max_inpower = cursor.fetchone()
+            # max_inpower = max_inpower[0] if max_inpower else None
+
+            # inpower = self.get_port_power(int(inp))
+            # if max_inpower:
+            #     max_inpower_val = float(max_inpower)
+            # else:
+            #     max_inpower_val = 20.0
+
+            # if inpower > max_inpower_val:
+            #     message = "%s (%s): %.2f dBm > %s (%s): %.2f dBm" % (
+            #         input_comp,
+            #         inp,
+            #         inpower,
+            #         output_comp,
+            #         outp,
+            #         max_inpower_val,
+            #     )
+            #     # self.logger("Patch max power exceeded: %s" % message)
+            #     raise Exception("Patch max power exceeded: %s" % message)
+            # else:
+            self.__conn(inp, outp)
+            time.sleep(1)
+            inpower = self.get_port_power(int(inp))
+            outpower = self.get_port_power(int(outp))
+            data = "%s (%s): %.2f dBm ---> %s (%s): %.2f dBm" % (
+                input_comp,
+                inp,
+                inpower,
+                output_comp,
+                outp,
+                outpower,
+            )
+            print(data)
+                # self.logger("Connect %s" % (data))
+
+        # Close the cursor and connection
+        cursor.close()
+        conn.close()
+
+    def disconnect_devices(self, equipment_1, equipment_2):
+
+        """Disconnect patching between two devices from the Polatis switch.
+
+        :param equipment_1: The name of the first device.
+        :type equipment_1: str
+
+        :param equipment_2: The name of the second device.
+        :type equipment_2: str
+
+        return: None
+        :rtype: None
+
+        raises Exception: If the port names are incorrect, or are allocated to other users.
+        """
+
+        self.disconnect_patch_list([(equipment_1, equipment_2)])
+
+    def disconnect_patch_list(self, patch_list):
+
+        """Disconnect a list of patches from the Polatis switch. The patch list is a list of tuples, where each tuple contains two elements: the input component and the output component.
+
+        :param patch_list: A list of patches, where each patch is a list of ports.
+        :type patch_list: list
+
+        :raises Exception: If patch_list is not a list or if it is empty.
+        :raises Exception: If the port names are incorrect, or are allocated to other users.
+
+        :return: None
+        :rtype: None
+
+        """
+
+        if not isinstance(patch_list, list):
+            raise Exception("Argument patch_list must be a list of tuples of patches")
+        if len(patch_list) == 0:
+            raise Exception("Argument patch_list must not be empty")
+
+        if not check_patch_owners(patch_list):
+            print("apply_patch_list failed")
+            raise Exception(
+                "apply_patch_list failed, some (or all) ports are not available. Please contact admin."
+            )
+
+        # Connect to the MySQL database
+        conn = mysql.connector.connect(
+            host="127.0.0.1", user="testbed", password="mypassword", database="provdb"
+        )
+        cursor = conn.cursor()
+
+        for patch in patch_list:
+
+            input_comp, output_comp = patch
+
+            # Fetch the 'In' and 'Out' values from the Ports table
+            cursor.execute(
+                "SELECT `Out_Port` FROM device_table WHERE polatis_name = %s", (input_comp,)
+            )
+            inp = cursor.fetchone()[0]
+
+            cursor.execute(
+                "SELECT `In_Port` FROM device_table WHERE polatis_name = %s", (output_comp,)
+            )
+            outp = cursor.fetchone()[0]
+
+            self.__disconn(inp, outp)
+            time.sleep(1)
+        # Close the cursor and connection
+        cursor.close()
+        conn.close()
+
+    def release_ports(self, patch_list, username):
+        """ADMIN ONLY: Allocate the ports in the patch list to user/NULL.
+
+        :param patch_list: A list of patches, where each patch is a list of ports.
+        :type patch_list: list
+
+        :param username: The username to allocate the ports to.
+        :type username: str
+
+        :return: None
+        :rtype: None
+
+        """
+
+        with open("/etc/secure_keys/mysql_key.key", "r") as file:
+            lines = file.readlines()
+            admin_user = lines[0].strip()
+            password = lines[1].strip()
+
+        # Connect to the MySQL database
+        conn = mysql.connector.connect(
+            host="127.0.0.1", user=admin_user, password=password, database="provdb"
+        )
+        cursor = conn.cursor()
+
+        for patch in patch_list:
+            for name in patch:
+                if name == "NULL":
+                    continue
+
+                # Set owner to NULL where the owner is the Unix user and the name matches
+                cursor.execute(
+                    "UPDATE ports_new SET Owner = %s WHERE Name = %s",
+                    (username, name),
+                )
+
+        # Commit the changes
+        conn.commit()
+
+        # Close the cursor and connection
+        cursor.close()
+        conn.close()
+
+    def print_patch_table(self, patch_list):
+
+        """Prints the patch table based on the given patch list.
+
+        :raises Exception: If patch_list is not a list or if it is empty.
+        :raises Exception: If the port max power is exceeded.
+        :raises Exception: If the ports are not available, or are allocated to other users.
+
+        :param patch_list: A list of patches, where each patch is a list of ports.
+        :type patch_list: list
+
+        :return: None
+        :rtype: None
+        """
+
+        if not isinstance(patch_list, list):
+            raise Exception("Argument patch_list must be a list of tuples of patches")
+        if len(patch_list) == 0:
+            raise Exception("Argument patch_list must not be empty")
+        for patch in patch_list:
+            inx, outx = patch
+            inp = self.get_inport(inx)
+            outp = self.get_outport(outx)
+            inpower = self.get_port_power(int(inp))
+            outpower = self.get_port_power(int(outp))
+            data = f"{inx}({inp}): {inpower} dBm ----> {outx}({outp}): {outpower} dBm"
+            print(data)
+
+    def get_patch_table_csv(self, patch_list, filename):
+        """
+        Writes the patch table to a CSV file.
+
+        :param patch_list: A list of patches, where each patch is a list of ports.
+        :type patch_list: list
+
+        :param filename: The location of the CSV file.
+        :type filename: str
+
+        :raises Exception: If patch_list is not a list or if it is empty.
+
+        :return: None
+        :rtype: None
+        """
+        if not isinstance(patch_list, list):
+            raise Exception("Argument patch_list must be a list of tuples of patches")
+        if len(patch_list) == 0:
+            raise Exception("Argument patch_list must not be empty")
+        data = []
+        for patch in patch_list:
+            inx, outx = patch
+            inp = self.get_inport(inx)
+            outp = self.get_outport(outx)
+            inpower = self.get_port_power(int(inp))
+            outpower = self.get_port_power(int(outp))
+            data.append([inx, "Out", inp, inpower])
+            data.append([outx, "In", outp, outpower])
+        with open(filename, "w") as f:
+            writer = csv.writer(f)
+            writer.writerows(data)
+
+    def _get_patch_data(self, patch_list):
+        """Internal method to gather patch data."""
+        if not isinstance(patch_list, list):
+            raise Exception("Argument patch_list must be a list of tuples of patches")
+        if len(patch_list) == 0:
+            raise Exception("Argument patch_list must not be empty")
+        data = []
+        for patch in patch_list:
+            inx, outx = patch
+            inp = self.get_inport(inx)
+            outp = self.get_outport(outx)
+            inpower = self.get_port_power(int(inp))
+            outpower = self.get_port_power(int(outp))
+            data.append([inx, "Out", inp, inpower])
+            data.append([outx, "In", outp, outpower])
+        return data
+
+    def get_patch_table_csv(self, patch_list, filename):
+        data = self._get_patch_data(patch_list)
+        with open(filename, "w") as f:
+            writer = csv.writer(f)
+            writer.writerows(data)
+
+    def get_patch_table_list(self, patch_list):
+        return self._get_patch_data(patch_list)
+
+    def get_NE_type(self):
+        line = "RTRV-NETYPE:::123:;"
+        lines = self.__sendcmd(line)
+        for line in lines.split("\n"):
+            m = re.match(r'\W*"(\S+),(\S+),(\S+),(\S+)"', line)
+            if m:
+                print(m.group(1), m.group(2), m.group(3), m.group(4))
+
+    def get_all_patch(self):
+        line = "RTRV-PATCH:::123:;"
+        lines = self.__sendcmd(line)
+        for line in lines.split("\n"):
+            m = re.match(r'\W*"(\d+),(\d+)"', line)
+            if m:
+                self.patch[int(m.group(1))] = int(m.group(2))
+        return
+
+    def get_all_atten(self):
+        line = "RTRV-PORT-ATTEN::1&&640:123:;"
+        lines = self.__sendcmd(line)
+        print(lines)
+
+    def get_all_labels(self):
+        line = "RTRV-PORT-LABEL::1&&640:123:;"
+        lines = self.__sendcmd(line)
+        for line in lines.split("\n"):
+            m = re.match(r'\W*"(\d+):(\S+)"', line)
+            if m:
+                self.label[int(m.group(1))] = m.group(2)
+        print(self.label)
+        return
+
+    def get_all_shutter(self):
+        line = "RTRV-PORT-SHUTTER::1&&640:123:;"
+        lines = self.__sendcmd(line)
+        for line in lines.split("\n"):
+            m = re.match(r'\W*"(\d+):(\S+)"', line)
+            if m:
+                self.shutter[int(m.group(1))] = m.group(2)
+        return
+
+    def get_all_pmon(self):
+        line = "RTRV-PORT-PMON::1&&640:123:;"
+        lines = self.__sendcmd(line)
+        for line in lines.split("\n"):
+            m = re.match(r'\W*"(\d+):(\S+),(\S+),(\S+)"', line)
+            if m:
+                self.wavelength[int(m.group(1))] = float(m.group(2))
+                self.offset[int(m.group(1))] = float(m.group(3))
+                self.atime[int(m.group(1))] = float(m.group(4))
+        line = "RTRV-EQPT::PMON:123:::PARAMETER=CONFIG;"
+        lines = self.__sendcmd(line)
+        for line in lines.split("\n"):
+            m = re.match(r'\W*"PMON::PORT=(\d+),MODE=(\S+)"', line)
+            if m:
+                self.monmode[int(m.group(1))] = m.group(2)
+        return
+
+    def get_all_power(self):
+        line = "RTRV-PORT-POWER::1&&640:123:;"
+        lines = self.__sendcmd(line)
+        for line in lines.split("\n"):
+            m = re.match(r'\W*"(\d+):(\S+)"', line)
+            if m:
+                self.power[int(m.group(1))] = float(m.group(2))
+        return
+
+    def test_all_power(self):
+        self.get_all_power()
+        while True:
+            line = "RTRV-PORT-POWER::1&&640:123:;"
+            lines = self.__sendcmd(line)
+            for line in lines.split("\n"):
+                m = re.match(r'\W*"(\d+):(\S+)"', line)
+                if m:
+                    port = int(m.group(1))
+                    power = float(m.group(2))
+                    if abs(self.power[port] - power) > 3:
+                        if power > self.power[port]:
+                            transit = "Up"
+                        else:
+                            transit = "Down"
+                        print(
+                            "%s: %d %.2f -> %.2f"
+                            % (transit, port, self.power[port], power)
+                        )
+                    self.power[port] = float(power)
+
+    def get_port_power(self, port):
+        """Get the power of a port. The ports must be the absolute port number, not the component name.
+
+        :param port: The port number.
+        :type port: int
+
+        :return: The power of the port.
+        :rtype: float
+        """
+        line = "RTRV-PORT-POWER::%d:123:;" % port
+        lines = self.__sendcmd(line)
+        for line in lines.split("\n"):
+            m = re.match(r'\W*"(\d+):(\S+)"', line)
+            if m:
+                return float(m.group(2))
+        return -99.99
+
+    def get_device_power(self, equipment, io):
+        """Get the input/output power of a device.
+
+        :param port: The name of the device
+        :type port: str
+
+        :param io: The input/output port of the device, either "in" or "out".
+        :type io: str
+
+        :return: The power of the port.
+        :rtype: float
+        """
+        if io == "in":
+            port = int(self.get_outport(equipment))
+        elif io == "out":
+            port = int(self.get_inport(equipment))
+        return self.get_port_power(port)
+
+    def getall(self):
+        self.get_all_patch()
+        self.get_all_shutter()
+        self.get_all_pmon()
+        self.get_all_power()
+
+    def report_all(self):
+        print("REPORTING FUNCTION CALLED - 1")
+        return_dict = {}
+        for i in sorted(self.power.keys()):
+            try:
+                patch = self.patch.get(i, 0)
+                shutter = self.shutter.get(i, "")
+                monmode = self.monmode.get(i, "")
+                wavelength = self.wavelength.get(i, 0.0)
+                offset = self.offset.get(i, 0.0)
+                atime = self.atime.get(i, 0.0)
+                power = self.power.get(i, 0.0)
+            except Exception as e:
+                print(f"The key {i} failed: {e}")
+            # print(i, patch, shutter, monmode, wavelength, offset, atime, power)
+            return_dict[i] = [patch, shutter, monmode, wavelength, offset, atime, power]
+        return return_dict
diff --git a/polatis_old.py b/polatis_old.py
new file mode 100644
index 0000000..aa2d82c
--- /dev/null
+++ b/polatis_old.py
@@ -0,0 +1,3 @@
+from .polatis.polatis_old import Polatis
+
+__all__ = ["Polatis"]
diff --git a/utils.py b/utils.py
index 4726ffc..a5d4eb5 100644
--- a/utils.py
+++ b/utils.py
@@ -68,7 +68,7 @@ def check_patch_owners(patch_list):
         return True
 
     conn = mysql.connector.connect(
-        host=os.getenv("DB_HOST", "127.0.0.1"),
+        host=os.getenv("DB_HOST", "10.10.10.8"),
         user=os.getenv("DB_USER", "testbed"),
         password=os.getenv("DB_PASSWORD", "mypassword"),
         database=os.getenv("DB_NAME", "provdb")
